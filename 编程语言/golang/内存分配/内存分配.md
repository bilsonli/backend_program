# 内存分配
Go编译器会尽可能将变量分配到到栈上，但实际分配到哪儿是由逃逸分析来决定的

# 逃逸分析
## 指针逃逸
函数返回局部变量的指针  

## 动态类型逃逸(interface)
函数接收值为interface{类型，例如fmt.Prinln}  

## 内存过大(栈空间不足)
申请过大的内存空间，超过栈空间  

## 闭包
闭包函数内使用了外部变量  

## 空间大小不确定
```
func test() {
	l := 1
	a := make([]int, l, l)
	for i := 0; i < l; i++ {
		a[i] = i
	}
}
```

l虽然赋值为1，但是编译器不知道


## 参考链接
https://juejin.cn/post/7169403270719340574
