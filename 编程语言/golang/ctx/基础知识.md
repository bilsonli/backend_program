# 基础的ctx
![image](https://github.com/user-attachments/assets/d9e6527f-08bb-4e27-b2c8-a06fedca04c7)


# emptyctx
空的ctx  

# valueCtx
携带key，value的ctx  
```
type valueCtx struct {
	Context
	key, val any
}
```

# cancelCtx
可以取消的ctx，父级ctx取消，所有子集ctx都取消，子级ctx取消，会从父级的ctx中摘除  
```
type cancelCtx struct {
	Context

	mu       sync.Mutex            // protects following fields
	done     atomic.Value          // of chan struct{}, created lazily, closed by first cancel call
	children map[canceler]struct{} // set to nil by the first cancel call
	err      error                 // set to non-nil by the first cancel call
	cause    error                 // set to non-nil by the first cancel call
}
```

# timerCtx
携带定时器的cancelCtx，一般用来做超时处理  
```
type timerCtx struct {
	cancelCtx
	timer *time.Timer // Under cancelCtx.mu.

	deadline time.Time
}
```

# ctx使用原则
除了框架层不要使用 WithValue 携带业务数据，这个类型是 interface{}``, 编译期无法确定，运行时assert` 有开销。如果真要携带也要用 thread-safe 的数据  
一定不要打印 Context, 尤其是从 http 标准库派生出来的，谁知道里面存了什么  
Context 通常做为第一个参数传给函数，但如果 Context 生命周期等同于结构体，当成结构体成员也可以  
尽可能不要自定义用户层 Context, 除非收益巨大  
异步 goroutine 逻辑使用 Context 时要清楚谁还持有，会不会提前超时，尤其调 rpc, db, redis 时  
派生出来的 child ctx 一定要配合 defer cancel() 使用，释放资源  
 
Context 是线程安全的，可以放心的在多个 goroutine 协程中传递  


可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。  


不要把 Context 放在结构体中，要以参数的方式传递，parent Context 一般为Background，并且一般要在 main 函数的入口处创建然后传递下去  


Context 的变量名建议都统一为 ctx，并且要把 Context 作为第一个参数传递给入口请求和出口请求链路上的每一个函数  


往下游给一个函数方法传递 Context 的时候，千万不要传递 nil，否则在 tarce 追踪的时候，就会中断链路，并且如果函数里面有获取值的逻辑，可能导致 panic。  


Context 的 Value 只能传递一些通用或者基础的元数据，不要传递业务层面的数据，不是说不可以传递，是在 Go 的编码规范或者惯用法中不提倡不要什么数据都使用这个传递。由于 context 存储 key-value 是链式的，因此查询复杂度为O(n)，所以，尽量不要随意存储不必要的数据   
