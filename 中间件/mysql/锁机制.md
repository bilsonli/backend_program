# mysql锁
## 行锁和表锁
表锁：锁定整张表  
行锁：锁定表中的某些行  

## 表锁场景
### 表锁类型
1）表锁(用户主动加锁或者没有使用到索引时)  
2）元数据锁(修改表结构时加元数据写锁，增删改查表时加元数据读锁)  
3）意向锁(加行锁时，引擎自动加表级意向锁)  
![image](https://github.com/user-attachments/assets/ea89dbae-1499-4e91-8611-27b508f93017)

### 意向锁意义
解决行锁和表锁的冲突  
例如A申请了行级读锁，B想申请表级写锁，在没有意向锁的情况下，B需要先判断是否有表锁，再判断每一行是否有加锁（效率太低）  
有了意向锁后，只需要判断是否有意向锁即可（说明有行级数据被锁定）  


## 共享锁和排他锁
类似于读写锁  

## 意向锁
意向共享锁（IS）：事务在给数据行加行级共享锁之前，必须先取得该表的 IS 锁  
意向排他锁（IX）：事务在给数据行加行级排他锁之前，必须先取得该表的 IX 锁   
特点：表级锁，InnoDB自动添加，无需用户干预  

## 行锁
### 记录锁
锁定表中某些确定的行  

### Gap锁
锁定间隙  

### next-key锁
记录锁 + 间隙锁

## 插入意向锁
属于间隙锁，而不是意向锁   
作用：提高并发插入的性能。间隙锁不允许多个事务同时插入同一个索引间隙，但是插入意向锁允许多个事务同时插入同一个索引间隙内的不同数据值   


# 加锁原理（非常复杂，具体情况具体看）
InnoDB加的行锁是netx-key锁  
如果锁的主键索引记录存在，则退化成纪录锁  
如果锁的主键索引记录不存在，则加间隙锁  

唯一索引等值查询：  
当查询的记录是存在的，next-key lock 会退化成「记录锁」。当查询的记录是不存在的，next-key lock 会退化成「间隙锁」。  

非唯一索引等值查询：  
当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。  

非唯一索引和主键索引的范围查询的加锁规则不同之处在于：  
唯一索引在满足一些条件的时候，next-key lock 退化为间隙锁和记录锁。非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。  

# 死锁
## 原理
条件：互斥、占有且申请、不可抢占、循环等待  
例子：   
1）A锁定资源1  
2）B锁定资源2  
3）A申请资源2  
4）B申请资源1  

## 解决办法
1）开启死锁检测：检测到死锁时，自动回滚其中一个事务  
2）设置事务超时时间：超时直接回滚事务  


# 参考资料
https://www.cnblogs.com/better-farther-world2099/articles/14955475.html  
https://xiaolincoding.com/mysql/lock/how_to_lock.html#mysql-%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84
https://www.cnblogs.com/chanshuyi/p/mysql-table-lock-and-row-lock.html
